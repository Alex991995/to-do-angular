## HOO (Higher order observables) и какую проблему они решают

1. Higher Order Observable — это Observable, который эмитит другие Observable как значения.
   Например: Observable<Observable<number>>.
2. Служит для управление вложенными потоками.
3. 1. mergeMap — подписывается на все внутренние observable параллельно.
   2. concatMap — выполняет по очереди, дожидаясь завершения каждого.
   3. switchMap — отменяет предыдущий и подписывается только на последний.
   4. exhaustMap — игнорирует новые, пока текущий не завершится.

4. promise vs observable

| **Критерий**           | **Promise**                   | **Observable**                  |
| ---------------------- | ----------------------------- | ------------------------------- |
| Ленивая/жадная         | Жадный — начинает сразу       | Ленивый — начинает при подписке |
| Множественные значения | Нет, только одно              | Да, поток значений              |
| Отмена                 | Нельзя напрямую               | Можно отписаться                |
| Операторы              | Почти нет                     | Много (map, filter, switchMap…) |
| Push/Pull модель       | Push только одного результата | Push любого кол-ва событий      |
| Статус                 | Неизменяемый после завершения | Можно бесконечно эмитить        |

Promise — для одного значения (разовый асинхронный результат).
Observable — для потоков данных и отменяемых асинхронных операций.

3. hot vs cold observables

Cold Observable — начинает эмитить значения только при подписке. Каждый подписчик получает свою копию событий.

Hot Observable — уже эмитит значения, даже без подписчиков. Подписчики получают текущий момент потока, а не начало. Пример: fromEvent, interval (если через Subject).

4. типы Subjects

5. Типы Subjects
   | **Тип** | **Особенности** |
   | ------------------- | --------------------------------------------------------------------- |
   | **Subject** | Передаёт только значения, отправленные после подписки. |
   | **BehaviorSubject** | Хранит **последнее значение** и сразу отдаёт его новому подписчику. |
   | **ReplaySubject** | Хранит **n** последних значений и отдаёт их новым подписчикам. |
   | **AsyncSubject** | Отдаёт **только последнее значение**, но **только после complete()**. |

## Методы

1. debounceTime(ms)
   Ждёт паузу ms мс после последнего значения перед эмитом.
   Используется для поиска по вводу, чтобы не отправлять запрос на каждую букву.

2. throttleTime(ms)
   Эмитит первое значение и игнорирует последующие в течение ms мс.
   Используется для ограничения частоты (например, обработка скролла)

3. distinctUntilChanged()
   Эмитит только если значение отличается от предыдущего.
   Часто применяется с формами или фильтрами, чтобы не отправлять одинаковые значения.

4. catchError(fn)
   Перехватывает ошибку, позволяет вернуть другой Observable или пробросить ошибку дальше.

5. finalize(fn)
   Вызывается всегда при завершении (успех, ошибка, отписка).

6. combineLatest(...obs)
   Эмитит массив последних значений всех потоков, когда хоть один меняется.
   Работает бесконечно, пока хотя бы один поток активен.

7. forkJoin(...obs)
   Ждёт завершения всех потоков, выдаёт массив последних значений.
   Используется для параллельных запросов.

8. zip(...obs)
   Эмитит массив, беря по одному значению из каждого потока.
   Завершается, когда закончится один из потоков.

9. Слияние потоков
   merge(...obs)
   Объединяет потоки, эмитит значения по мере поступления.

10. concat(...obs)
    Запускает потоки по очереди, каждый следующий после завершения предыдущего.

11. race(...obs)
    Отдаёт значения только того потока, который первый эмитит.

## Commands

1. npm i
2. npm run start

### to run a server

3. npm run server
   it will create the server on 3000 localhost port
